{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":12146807329178785087,"abi":{"parameters":[{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"priv_key","type":{"kind":"field"},"visibility":"private"},{"name":"note_root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"note_hash_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifierHash","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"index":[{"start":3,"end":4}],"note_hash_path":[{"start":4,"end":7}],"note_root":[{"start":2,"end":3}],"nullifierHash":[{"start":8,"end":9}],"priv_key":[{"start":1,"end":2}],"recipient":[{"start":0,"end":1}],"secret":[{"start":7,"end":8}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[12],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1b2W7iSBS1IYTywr7TnfS+d0fGNja88SuhAWleRqPRfNb8xvzXUPjWpHKnWm2UWyWsrpIQdY6Te46P7YpjLq5TjPD4YjBvwLsrvY8d9djAe/Skke311M2Xmvx+r1jdtaa6WcX8ajof8lhP3eReT9040pTDVk9duz5ormvXh6JuxdaHfCfquXoEokUN1XWJ69fpakV1qOMdX/7xFRxfNfBcB96VsI9woAjySuP+JlGWpvs83i+SxX0Ur7erZZQut9lqsVosV8tdvEqS/Spd5evtOo/WizTZLw7LdXKAYh5Brf2hGD5drV1AeEwb0jES59+dox40mrr+2GhbXHI9dZcHTX41LYbZoVp181RPXXvTWAx7HRfDXsd66+q6jh9u7mjr6rqOk1216urKQdu6U7HzV9c6adczvXXtfUkxKndfYteH07Drg966+u93tD3MkmvWNNQWtZ76YCek8xXxMMVDrGsp4DrwDeCbwMn5MOfhYISq8P6Gd+Y8PlgbCvPpIjsZBvf4I8iatE28M+BdwC7ia4BriK8DriP+CvAV4huAG4i/BnyN+CbgJuKZwIj3AHuI9wH7iA8AB4gPAYeIbwFuIb4NuI34DuAO4ruAu4jvAe4hvg+4j/gB4AHih4CHiB8BHkm82MbHxqE6B6OI161T1z0uGPwpqTh9he9Amott/MK8hXnv+BqLDc7DvgvKJfTHQJt2vxenp8ONx7vwvxV/I82b0n5ek/vRtZ/FecMk7zR18y3PykNZNVBWbelnZA+ehvxcSVfUFthTaNNlEcdc2y+Rha/w4xvOwldo02WRnc6LoEQWgcJPYDiLQKFNmMWaa4clsggVfkLDWYQKbcIs9ly7VSKLlsJPy3AWLYU2YRapC/v6syzaCj9tw1kIvXM9exfgmaE5jXZyz7U7JbLoKPx0DGch9M717F2AZ4bmNNp5wrW7JbLoKvx0DWfRVWgTZnFai3olsugp/PQMZ9FTaBNmcbqP65fIoq/w0zechdA713NQQc/hBXhmaE6jneVce1Aii4HCz8BwFkLvXM/eBXhmaE6jHX/n2sMSWQwVfoaGsxB653r2LsAzQ3Ma7ex0/EYlshgp/IwMZzFSaBNmscRfsflRFmOFn7HhLITeuZ7DCnruV9Bz9wI8MzSn0c5WXHtSIouJws/EcBZC71zPXgU9ty/AM0NzGu3k9L/JtEQWU4WfqeEshF4VPTM0p9HOd1x7ViKLmcLPzHAWM0lbcISf6UW+tO9//Pnb7385aFwp5txADebyHyVR6Eb6naaijus8/gqH2MEx2i5vu0G/zxfFf6TtYmwconDSeC83G+CvmNSkbbbZoMC/crMB58UH8WPETwBPED8FPEX8DPAM8XPAc8Q/A/wM8c8BP0f8DeAbxN8CvkX8C8AvEP8S8EvEvwL8CvGvAb9G/BvAbxD/FvBbxL8D/A7x7wG/R/wHwB8Q/xHwR8R/AvwJ8Z8Bf0b8F8BfEP8V8FfEfwP87RdpVhFf+uUPae9sswrpcdCzn7ZZxXFss4qchW1Wsc0qqixss4ptVlFlYZtV8LDNKqY8M8c2q9hmFdusosrCNquY9cwc26xim1XwsM0qpjwzxzar2GYV26xim1XKe2aObVaxzSpmPTNHS7NKahs//ssiq2rjx4w8i6IJZl4ii7nCz9xwFnNJ+yKbYO4k7qlNMHdou7xN1QTzL/1unB2xXwAA","debug_symbols":"zdvBahtXAIXhd9HaBJ3RzJl78yqlFCdxisHYIXYKxeTda7d2WlpD8bfyTiPdg+7i1+b/0f3h08WHb7/+cnn9+eb28P6n+8PVzcfzu8ub64en+8Pxz7duv5xfPz7d3p1/vTu8nzmeHS6uPz28Wk/fzw6fL68uDu/Xfv/57JCXBjl2f1oky/zn5Oy/h7eO58PbXP/ncPN8dowfR5fl8SrL27nK6e1cZX07V9nezlX64lVy2n5cZS7/Iv347vTir2PP6Wm0n/7+mtPxaRPYLLA5wWaFzQabwmaHzYDNfP1mBQ5W4GAFDlbgYAUOVuBgBQ5W4GAFDlbgYAMONuBgAw424GADDjbgYAMONuBgAw424KDAQYGDAgcFDgocFDgocFDgoMBBgYMdONiBgx042IGDHTjYgYMdONiBgx042IGDARwM4GAABwM4GMDBAA4GcDCAgwEcDOBgAgcTOJjAwQQOJnAwgYMJHEzgYAIHEzjI8SijyGiR0UlGq4w2GVVGu4yGjISICBERIiJERIiIEBEhIkJEhIgIEREiFiFiESIWIWIRIhYhYhEiFiFiESIWIWIRIkQ3RnxjRDhGjGNEOUacY0Q6RqxjRDtGvGNEPEbMY0Q9RtxjRD5G7GNEP0b8Y0RARgxkREFGHGREQkYsZERDRjxkRERGTGRERUZcZERGRmxkREdGfGRESEaMZERJRpxkREpGrGReryULKaCQAgopoJACCimgkAIKKaCQAgopoJACCimgkAIKKaCQAgopoJAC+k5+cztwsAMHO3CwAwc7cLADBztwsAMHO3AwgIMBHAzgYAAHAzgYwMEADgZwMICDARxM4GACBxM4mMDBBA4mcDCBgwkcTOBgAgeQAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimgkgIqKaCSAiopoJICKimglgIiXjIiJiNmMqImI24yIicjdjKiJyN+MiIoI4YyoigjjjIiKSOWMqIpI54yIiojpjKiKiOuMiIrI7YyoivzWl/58PDb+dfL8w9XF4//pX787Nv1x+e/Vj883v3+5a9PHs7+AQ==","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"46":{"source":"use dep::std;\nuse dep::std::ec::tecurve::affine::{Curve, Point};\n\n\nfn main(\n  recipient: pub Field,\n  // Private key of note\n  // all notes have the same denomination\n  priv_key: Field,\n  // Merkle membership proof\n  note_root: pub Field,\n  index: Field,\n  note_hash_path: [Field; 3],\n  // Random secret to keep note_commitment private\n  secret: Field,\n  // Hash to be checked against the nullifier computed in the circuit\n  nullifierHash: pub Field,\n) -> pub Field {\n    // Compute public key from private key to show ownership\n    let pubkey = std::embedded_curve_ops::fixed_base_scalar_mul(priv_key, 3);\n    let pubkey_x = pubkey[0];\n    let pubkey_y = pubkey[1];\n\n    // Compute input note commitment\n    let note_commitment = std::hash::pedersen_hash([pubkey_x, pubkey_y, secret]);\n\n    // Compute input note nullifier\n    let nullifier = std::hash::pedersen_hash([note_commitment, index, priv_key]);\n    println(\"nullifier: {nullifier}\");\n    // assert(nullifierHash == nullifier);\n\n    // Check that the input note commitment is in the root\n    let new_root = compute_root_from_leaf(note_commitment, index, note_hash_path);\n    println(\"new_root: {new_root} == note_root: {note_root}\");\n    // assert(new_root == note_root);\n\n    // Cannot have unused variables, return the recipient as public output of the circuit\n    recipient\n}\n\n// Returns the root of the tree from the provided leaf and its hashpath, using mimc hash\nfn compute_root_from_leaf(leaf : Field, index : Field, hash_path: [Field; 3]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n\n        current = std::hash::mimc::mimc_bn254([hash_left, hash_right]);\n    };\n    current\n}\n\n\n#[test]\nfn test_main() {\n    // # Random test key\n    let recipient = 0x00000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8 as Field;\n    let priv_key = 0x000000000000000000000000000000000000000000000000000000616c696365;\n    let note_root = 0x2f36d4404719a30512af45be47c9732e916cb131933102b04ba6432602db209c;\n    let index = 0;\n    let note_hash_path = [\n        0x1e61bdae0f027b1b2159e1f9d3f8d00fa668a952dddd822fda80dc745d6f65cc,\n        0x0e4223f3925f98934393c74975142bd73079ab0621f4ee133cee050a3c194f1a,\n        0x2fd7bb412155bf8693a3bd2a3e7581a679c95c68a052f835dddca85fa1569a40\n    ];\n    let secret = 0x1929ea3ab8d9106a899386883d9428f8256cfedb3c4f6b66bf4aa4d28a79988f;\n    let nullifierHash = 0x1929ea3ab8d9106a899386883d9428f8256cfedb3c4f6b66bf4aa4d28a79988f;\n\n    let res = main(\n        recipient,\n        priv_key,\n        note_root,\n        index,\n        note_hash_path,\n        secret,\n        nullifierHash\n    );\n    println(f\"Shielded output: {res}\");\n}","path":"/Users/peita/Dev/aztec/movement/circuits/shielded_attack/src/main.nr"}},"names":["main"]}