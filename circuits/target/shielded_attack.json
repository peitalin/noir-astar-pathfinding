{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":52178667091691454,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"private"},{"name":"attack_coordinates","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"missile_token_id","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_index","type":{"kind":"field"},"visibility":"private"},{"name":"hash_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"priv_key","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"attack_coordinates":[{"start":1,"end":3}],"hash_path":[{"start":5,"end":8}],"merkle_index":[{"start":4,"end":5}],"missile_token_id":[{"start":3,"end":4}],"priv_key":[{"start":8,"end":9}],"root":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[27],"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VZ7W6CQBBcxFatYNWq9aNNbNMmbdImdwIK//oqNeL7P4GRjUc4iP+cTWCTixxcNjezu7MnOHSxIBvv5trJRi8bLWt+MvOTude7sq5rnvesdQ/Wc7L8sf2ZX3Wb6TbOl3KNn342vGz4Zv+8Z9fcd6y5V5n7Fr7c2oJ4A7UNw3S3SXWg/9Um2ceRCqP9NtaxjuLosImDII3DeJfsk51KdBik+hglwdE46wN8pceLeThfBx8YUzsWrUos6sBf7msAzBESqLM7K/+RHL6AY43GzRo2EMD9SjI57oL3+QjkEhhrjeZPol4k8mbdgHqR0Ik3aka9DIFcroG+kPxVz36sEXzmG1Jx9htR2dC91wP6GlO9e+89FWdNJIcfVG8t4RwaC+D+pGZoyROQS2CsNZo/iXqRyJuvmuNmjRgJ4P6mZtTLBMglMNYayV+197JGcM+dUNF7p1Q2dO/1gb5mVO/e26Hyex0U7h+qt5ZwDs0EcP9SM7TkGcglMNYazZ9EvUjkjao5btaIqQBuTc2olzmQS2CsNZK/au9ljeCeO6ei9y6obNXeq24zjYzZQoAb18LOnOTfhVyLo6UwR0sgRyvCcpR/D+pa+B3DAT/j94b8/6Vj1uR64lrXK7piZ5PkbJzNGwAA","debug_symbols":"zZhBasMwEEXvorUXnpFkyb5KKUVJnGIwcoidQjG+e6U2IoaKBGICfznW6PNm4QejWRza3eXzo/PHYRTN2yz6Ye+mbvChmkX5+2k8OR+rcXLnSTTSUiFafxCN0nopxLHrW9FoWop/rUTGXHuJ6dbM9fJeCMqlKyuvN7SyW9I5l17JxG7KB+ya6wSyGlNmQaqUSvbGzBwxJAaGwsDQGBgVBobZiGGoSq1s1xgh227MtpxareEHI979D2sUECphSAiGhGFIJAyJgiHRLxQEVTBjGhgSGGsSjDYZRpsMo02G0SbLFyqCYUzIGoYERpsMo02G0SbDaFPCaFNmtWnLtGdbVmuSeCOrt1qlpYdKouXp1TwUX+7cuV3fxkeGeHbx+/TmEMrp+/R3Enp/AA==","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"51":{"source":"use dep::std;\nmod compute_root;\n\n\nfn main(\n    root: Field, // merkle root for the transfer\n    attack_coordinates: [Field; 2], // coordinates of airship to attack\n    missile_token_id: pub Field,\n    merkle_index:  Field,\n    hash_path: [Field; 3],\n    priv_key: Field,\n) -> pub Field {\n\n    //prove knowledge of some priv_key and group secret\n    let hashed_attack_coordinates = std::hash::pedersen_hash([ attack_coordinates[0], attack_coordinates[1] ]);\n    let note_commitment = std::hash::pedersen_hash([ priv_key, hashed_attack_coordinates ]);\n\n    // check the attack is an eligible committed attack\n    let computed_root = std::merkle::compute_merkle_root(note_commitment, merkle_index, hash_path);\n    // println(f\"computed_root1: {computed_root}\");\n    // println(f\"root: {root}\");\n    assert(root == computed_root);\n\n    // return hash to check same priv_key doesn't re-use the same missile tokenId, store in contract\n    let nullifier = std::hash::pedersen_hash([ root, priv_key, missile_token_id ]);\n    nullifier\n}\n\n\n\nfn generate_merkle_root(priv_key: Field, index: Field, attack_coordinates: [Field; 2]) -> Field {\n\n    let mut commitments: [Field; 8] = [0; 8];\n    let hashed_attack_coordinates = std::hash::pedersen_hash([ attack_coordinates[0], attack_coordinates[1] ]);\n\n    // level 1 leafs\n    for i in 0..8 {\n        if i == index as u8 {\n            let commitment = std::hash::pedersen_hash([priv_key, hashed_attack_coordinates ]);\n            commitments[i] = commitment;\n        } else {\n            let commitment = std::hash::pedersen_hash([i as Field, hashed_attack_coordinates ]);\n            commitments[i] = commitment;\n        }\n    }\n\n    // level 2 branches\n    let branch_2a = std::hash::pedersen_hash([commitments[0], commitments[1]]);\n    let branch_2b = std::hash::pedersen_hash([commitments[2], commitments[3]]);\n    let branch_2c = std::hash::pedersen_hash([commitments[4], commitments[5]]);\n    let branch_2d = std::hash::pedersen_hash([commitments[6], commitments[7]]);\n\n    // level 3 branches\n    let branch_3a = std::hash::pedersen_hash([branch_2a, branch_2b]);\n    let branch_3b = std::hash::pedersen_hash([branch_2c, branch_2d]);\n\n    let merkle_root = std::hash::pedersen_hash([ branch_3a, branch_3b ]);\n\n    println(\"\");\n    println(\"[Merkle Tree]\");\n    println(f\"Root:\");\n    println(f\"{merkle_root}\");\n    println(\"\");\n\n    println(f\"Level 3 Branches\");\n    println(f\"L: {branch_3a}\");\n    println(f\"R: {branch_3b}\");\n    println(\"\");\n\n    println(f\"Level 2 Branches\");\n    println(f\"LL: {branch_2a}\");\n    println(f\"LR: {branch_2b}\");\n    println(f\"RL: {branch_2c}\");\n    println(f\"RR: {branch_2d}\");\n    println(\"\");\n\n    println(f\"Leafs:\");\n    for i in 0..8 {\n        let c = commitments[i];\n        println(f\"leaf {i}: {c}\");\n    }\n    println(\"\");\n    merkle_root\n}\n\n\n#[test]\nfn test_main() {\n\n    // create commitment\n    let attack_coordinates = [2, 3]; // coordinates of airship to attack, only player knows\n    let priv_key = 0x0000000000000000000000000000000000000000000000000000006666666666; // commitment[merkle_index]\n    let merkle_index =  2; // some index that server keeps track of\n    let root = generate_merkle_root(priv_key, merkle_index, attack_coordinates);\n    // root = 0x28316dfda7642eb77dfbc82bba01da0da726f80624adc2a03fab4315fb538046\n    let expected_nullifier = 0x2c893e5c6d5d74a6b30cdb6aecf3b757571a93c78e33c6ed0e665b11fad2834a;\n\n    let missile_token_id = 1234; // use as nullifier to prevent double spending\n\n    let hash_path = [\n        // hash_paths are indexed from: bottom leafs first, left to right;\n        0x299e0f032bbd01fd16326a4a33a86c6477ffc15067e799b7be4114e9a4adbc3a, // commitment_3\n        0x0bd31882ca4cd0f269c3dd7ae76c0dfc397ab0a745a557de521bd693d68329aa, // LL in level 2\n        0x0e258815841ece6567e5b339064066e30e2d51a2e10d8cbfbfa56aebd285d83c, // R in level 3\n    ];\n    //             root\n    //          /        \\\n    //        L            R\n    //     /     \\       /    \\\n    //   LL      LR     RL     RR\n    //  /  \\   /  \\    /  \\    /  \\\n    // 0   1   2   3   4   5   6   7\n\n\n    let nullifier_result = main(\n        root,\n        attack_coordinates,\n        missile_token_id,\n        merkle_index,\n        hash_path,\n        priv_key\n    );\n    println(\"\");\n    println(f\"Missile TokenId Nullifier: {nullifier_result}\");\n    // cannot reuse that missile again, burn it in the contract.\n    assert(nullifier_result == expected_nullifier);\n}","path":"/Users/peita/Dev/aztec/movement/circuits/shielded_attack/src/main.nr"}},"names":["main"]}